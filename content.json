[{"title":"前端面试题【Vue】","date":"2019-12-28T03:36:15.980Z","path":"2019/12/28/interview-vue/","text":"1、vue的两个核心是什么？12数据驱动,也叫双向数据绑定；组件系统 2、vue生命周期的理解1234567beforeCreated() 在实例创建之间执行，数据未加载状态created() 在实例创建、数据加载后，能初始化数据，dom渲染之前执行beforeMount() 虚拟dom已创建完成，在数据渲染前最后一次更改数据mounted() 页面、数据渲染完成，真实dom挂载完成beforeUpadate() 重新渲染之前触发updated() 数据已经更改完成，dom 也重新 render 完成,更改数据会陷入死循环beforeDestory() 和 destoryed() 前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行 3、vue的父组件和子组件生命周期钩子函数执行顺序？1234加载渲染过程 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted子组件更新过程 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated父组件更新过程 父 beforeUpdate -&gt; 父 updated销毁过程 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed 4、父组件可以监听到子组件的生命周期吗？12父组件引用子组件时通过 @hook 来监听想监听的生命周期即可即可&lt;Child @hook:mounted=\"doSomething\" &gt;&lt;/Child&gt; 5、谈一谈vue组件之间的参数传递？123父组件传给子组件：子组件通过props方法接收数据子组件传给父组件：$emit方法传递参数兄弟间组件通信：使用vuex解决问题 6、vue中 key 值的作用1key是为Vue中每个节点的唯一标识,通过这个key,我们的diff操作可以更准确、更快速。 7、vue 组件 data 为什么必须是函数1因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了。 8、v-model的原理123v-model只不过是一个语法糖而已,真正的实现靠的还是v-bind:绑定响应式数据触发 input 事件 并传递数据 (核心和重点)，可以通过model选项来修改prop和event 9、怎么给vue定义全局的方法？12第一种：挂载到Vue的prototype上第二种：利用全局混入mixin，因为mixin里面的methods会和创建的每个单文件组件合并 10、vue中怎么重置data？12345初始状态下设置data数据的默认值，重置时直接bject.assign(this.$data, this.$options.data())说明：this.$data获取当前状态下的datathis.$options.data()获取该组件初始状态下的data(即初始默认值)如果只想修改data的某个属性值，可以this[属性名] = this.$options.data()[属性名]，如this.message = this.$options.data().message 11、vue项目实现路由按需加载（懒加载）123vue异步组件技术 ==== 异步加载 component: resolve =&gt; require(['@/components/home'],resolve)路由懒加载(使用import) const Home = () =&gt; import(/* webpackChunkName: 'ImportFuncDemo' */ '@/components/home')webpack提供的require.ensure() component: r =&gt; require.ensure([], () =&gt; r(require('@/components/home')), 'demo') 12、解决vuex刷新后数据消失得问题123456789手动利用HTML5的本地存储： vuex的state在localStorage或sessionStorage或其它存储方式中取值 在mutations,定义的方法里对vuex的状态操作的同时对存储也做对应的操作。 这样state就会和存储一起存在并且与vuex同步利用vuex-persistedstate插件： import createPersistedState from \"vuex-persistedstate\" const store = new Vuex.Store(&#123; // ... plugins: [createPersistedState()] &#125;) 13、computed和watch有什么区别?12345computed是计算属性,也就是计算值,它更多用于计算值的场景computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算computed适用于计算比较消耗性能的计算场景watch更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作watch无缓存性，页面重新渲染时值不变化也会执行 14、Vue的双向绑定数据的原理1vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。 15、Proxy与Object.defineProperty的优劣对比123456Proxy可以直接监听对象而非属性Proxy可以直接监听数组的变化Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利Object.defineProperty得兼容性好,支持IE9 16、虚拟DOM实现原理1虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象,状态变更时，记录新虚拟dom树和旧虚拟dom树的差异,最后把差异更新到真正的dom中。 17、既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?123现代前端框架有两种方式侦测变化,一种是pull一种是push：pull: 其代表为React,我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新,然后React会进行一层层的Virtual Dom Diff操作找出差异,然后Patch到DOM上,React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。push: Vue的响应式系统则是push的代表,当Vue程序初始化的时候就会对数据data进行依赖的收集,一但数据发生变化,响应式系统就会立刻得知,因此Vue是一开始就知道是「在哪发生变化了」,但是这又会产生一个问题,如果你熟悉Vue的响应式系统就知道,通常一个绑定一个数据就需要一个Watcher,一但我们的绑定细粒度过高就会产生大量的Watcher,这会带来内存以及依赖追踪的开销,而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异,而Virtual Dom Diff则是pull操作,Vue是push+pull结合的方式进行变化侦测的。 18、Vue为什么没有类似于React中shouldComponentUpdate的生命周期？12React是pull的方式侦测变化,当React知道发生变化后,会使用Virtual Dom Diff进行差异检测,但是很多组件实际上是肯定不会发生变化的,这个时候需要用shouldComponentUpdate进行手动操作来减少diff,从而提高程序整体的性能。Vue是pull+push的方式侦测变化的,在一开始就知道那个组件发生了变化,因此在push的阶段并不需要手动控制diff,而组件内部采用的diff方式实际上是可以引入类似于shouldComponentUpdate相关生命周期的,但是通常合理大小的组件不会有过量的diff,手动优化的价值有限,因此目前Vue并没有考虑引入shouldComponentUpdate这种手动优化的生命周期。","link":"","tags":[]},{"title":"前端面试题【Js】","date":"2019-12-28T03:36:15.979Z","path":"2019/12/28/interview-js/","text":"1、介绍一下 JS 的基本数据类型1Undefined、Null、Boolean、Number、String 2、JavaScript 有几种类型的值？12栈：原始数据类型（Undefined，Null，Boolean，Number，String）堆：引用数据类型（对象、数组、函数） 3、原型/原型链/构造函数/实例/继承1每个对象都有__proto__(原型)属性 , __proto__指向创建他的构造函数的原型对象(prototype) 1、数组去重123456789101112131415var arr=['12','32','89','12','12','78','12','32'];es5:function unique1(array)&#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++)&#123; //遍历当前数组 if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n;&#125;es6:arr=[...new Set(arr)];function dedupe(array) &#123; return Array.from(new Set(array)); //Array.from()能把set结构转换为数组&#125; 3、你所知道的http的响应码及含义？123451xx(临时响应)2xx(成功)3xx(已重定向)4xx(请求错误)5xx(服务器错误) 3、说一下闭包？1闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包","link":"","tags":[]},{"title":"前端面试题【Html】","date":"2019-12-28T03:36:15.978Z","path":"2019/12/28/interview-html/","text":"1、介绍一下 JS 的基本数据类型1Undefined、Null、Boolean、Number、String","link":"","tags":[]},{"title":"前端面试题【Css】","date":"2019-12-28T03:36:15.977Z","path":"2019/12/28/interview-css/","text":"1、说一下盒模型？123456盒模型的组成，由里向外content,padding,border,margin.在IE盒子模型中，width表示content+padding+border这三个部分的宽度在标准的盒子模型中，width指content部分的宽度box-sizing: content-box 是W3C盒子模型box-sizing: border-box 是IE盒子模型box-sizing的默认属性是content-box 2、CSS选择器有哪些？12id选择器('#myid')、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=\"external\"]）、伪类选择器（a:hover, li:nth-child） 3、CSS选择器优先级排序1浏览器默认属性 &lt; 继承自父元素的属性 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; 结构伪类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important 4、position的值？1234static（默认）：按照正常文档流进行排列；relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；fixed(固定定位)：所固定的参照对像是可视窗口。 5、display:inline-block 什么时候会显示间隙？123有空格时候会有间隙 解决：移除空格margin正值的时候 解决：margin使用负值使用font-size时候 解决：font-size:0、letter-spacing、word-spacing","link":"","tags":[]}]